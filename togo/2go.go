package togo

import (
	"encoding/base64"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

var (
	iso8601Regex          = regexp.MustCompile(`^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)$`)
	base64Regex           = regexp.MustCompile(`^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$`)
	nonAlphaNumeric       = regexp.MustCompile(`\W+`)
	spaceFollowedByLetter = regexp.MustCompile(`\s+([a-zA-Z])`)
	validGoIdentifier     = regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_]*$`)
	titleCaser            = cases.Title(language.Und)
)

func ConvertToGoStructs(data any, formatType string, flatten, ptr bool) (string, error) {
	var (
		structs    = make(map[string]string)
		mainStruct = "AutoGenerated"
		result     strings.Builder
	)

	// If the top-level element is an array, take the first element as the base for struct generation
	if arr, ok := data.([]any); ok && len(arr) > 0 {
		data = arr[0]
	}

	structs[mainStruct] = parseScope(data, mainStruct, "", flatten, ptr, structs, formatType)

	keys := make([]string, 0, len(structs))
	for key := range structs {
		keys = append(keys, key)
	}

	sort.Strings(keys)
	for _, name := range keys {
		definition := structs[name]
		result.WriteString(fmt.Sprintf("type %s struct {\n%s}\n\n", name, definition))
	}

	code := result.String()
	wrappedCode := "package main\n\n" + code
	if err := validateGoCode(wrappedCode); err != nil {
		return "", fmt.Errorf("error validating Go code: %w", err)
	}

	formatted, err := format.Source([]byte(code))
	if err != nil {
		return "", fmt.Errorf("error formatting Go code: %w", err)
	}

	return string(formatted), nil
}

const failedNaming = "NAMING_FAILED"

// knownNameExceptions is a set of names that are known to be exempt from naming checks.
// This is usually because they are constrained by having to match names in the
// standard library.
// See: https://github.com/dominikh/go-tools/blob/915b568982be0ad65a98e822471748b328240ed0/stylecheck/st1003/st1003.go#L45-L51
var knownNameExceptions = map[string]bool{
	"LastInsertId": true, // must match database/sql
	"kWh":          true,
}

func fName(s string) string {
	if s == failedNaming {
		return failedNaming
	}
	if knownNameExceptions[s] {
		return s
	}
	dots := func(s string) string {
		var (
			result    strings.Builder
			upperNext = true
		)
		for _, r := range s {
			if r == '.' {
				upperNext = true
				continue
			}
			if upperNext {
				result.WriteRune(unicode.ToUpper(r))
				upperNext = false
			} else {
				result.WriteRune(r)
			}
		}
		return result.String()
	}
	s = dots(s)

	if s == lintName(s, initialisms()) {
		lintName(toCamelCase(s), initialisms())
	}
	return lintName(strings.ToUpper(string(s[0]))+s[1:], initialisms())
}

func parseScope(scope any, structName string, parentName string, flatten, ptr bool, structs map[string]string, formatType string) string {
	var goCode strings.Builder
	fieldNames := make(map[string]int)
	fieldOrder := make([]string, 0)
	usedNames := make(map[string]bool)

	switch scope := scope.(type) {
	case map[string]any:
		for k, v := range scope {
			fieldName := fName(k)
			if fieldName == "" || !validGoIdentifier.MatchString(fieldName) {
				fieldName = failedNaming
				if count, exists := fieldNames[fieldName]; exists {
					fieldNames[fieldName] = count + 1
					fieldName = fmt.Sprintf("%s%d", fieldName, count+1)
				} else {
					fieldNames[fieldName] = 1
				}
			}
			if isNumeric(fieldName) || startsWithDigit(fieldName) {
				fieldName = formatNumber(fieldName)
			}

			fieldType := goType(v, fieldName, parentName, flatten, ptr, structs, formatType)
			if _, exists := usedNames[fieldName]; exists {
				fieldName = parentName + fieldName
				fieldType = goType(v, fieldName, parentName, flatten, ptr, structs, formatType)
			}
			usedNames[fieldName] = true

			tag := getTag(k, formatType)

			if ptr {
				fieldType = "*" + fieldType
			}

			fieldOrder = append(fieldOrder, fmt.Sprintf("\t%s %s `%s`\n", fieldName, fieldType, tag))
		}
	case []any:
		if len(scope) > 0 {
			elemType := goType(scope[0], structName, parentName, flatten, ptr, structs, formatType)
			goCode.WriteString(fmt.Sprintf("[]%s", elemType))
		}
	}

	sort.Strings(fieldOrder)
	for _, field := range fieldOrder {
		goCode.WriteString(field)
	}
	return goCode.String()
}

func isBase64(s string) bool {
	if len(s)%4 != 0 {
		return false
	}

	if !base64Regex.MatchString(s) {
		return false
	}

	decoded, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		return false
	}

	for _, r := range decoded {
		if !utf8.ValidRune(rune(r)) || (r < 32 && r != 9 && r != 10 && r != 13) {
			return false
		}
	}
	return len(s) > 5
}

func goType(value any, fieldName string, parentName string, flatten, ptr bool, structs map[string]string, formatType string) string {
	switch value := value.(type) {
	case string:
		if iso8601Regex.MatchString(value) {
			return "time.Time"
		}
		if isBase64(value) {
			return "[]byte"
		}
		return "string"
	case float64:
		if value == float64(int64(value)) {
			if value >= -2147483648 && value <= 2147483647 {
				return "int"
			}
			return "int64"
		}
		return "float64"
	case bool:
		return "bool"
	case map[string]any:
		nestedStructName := titleCaser.String(fieldName)
		if !flatten {
			if _, exists := structs[nestedStructName]; exists {
				nestedStructName = titleCaser.String(parentName) + nestedStructName
			}
			structs[nestedStructName] = parseScope(value, nestedStructName, fieldName, flatten, ptr, structs, formatType)
			return nestedStructName
		}
		return "struct {\n" + parseScope(value, nestedStructName, fieldName, flatten, ptr, structs, formatType) + "\t}"
	case []any:
		if len(value) > 0 {
			elemType := goType(value[0], fieldName, parentName, flatten, ptr, structs, formatType)
			return "[]" + elemType
		}
		return "[]any"
	default:
		return "any"
	}
}

func getTag(key, formatType string) string {
	if formatType == "yaml" {
		return fmt.Sprintf("yaml:\"%s,omitempty\"", key)
	}
	return fmt.Sprintf("json:\"%s,omitempty\"", key)
}

func toCamelCase(str string) string {
	str = strings.ReplaceAll(str, "-", " ")
	str = strings.ReplaceAll(str, "_", " ")
	str = nonAlphaNumeric.ReplaceAllString(str, " ")
	camelStr := spaceFollowedByLetter.ReplaceAllStringFunc(str, func(s string) string {
		return strings.ToUpper(strings.TrimSpace(s))
	})
	return titleCaser.String(strings.ReplaceAll(camelStr, " ", ""))
}

func isNumeric(s string) bool {
	_, err := strconv.Atoi(s)
	return err == nil
}

func startsWithDigit(s string) bool {
	return len(s) > 0 && s[0] >= '0' && s[0] <= '9'
}

func formatNumber(str string) string {
	if str == "" {
		return ""
	}
	if isNumeric(str) {
		return "Num" + str
	}
	if startsWithDigit(str) {
		numbers := map[byte]string{
			'0': "Zero_",
			'1': "One_",
			'2': "Two_",
			'3': "Three_",
			'4': "Four_",
			'5': "Five_",
			'6': "Six_",
			'7': "Seven_",
			'8': "Eight_",
			'9': "Nine_",
		}
		return numbers[str[0]] + str[1:]
	}
	return str
}

func validateGoCode(code string) error {
	fset := token.NewFileSet()
	_, err := parser.ParseFile(fset, "", code, parser.AllErrors)
	if err != nil {
		return fmt.Errorf("go code validation failed: %w", err)
	}
	return nil
}
