package togo

import (
	"encoding/base64"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"unicode/utf8"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

var (
	// iso8601Regex expression to match if we get time.Time
	iso8601Regex = regexp.MustCompile(`^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)$`)
	// base64Regex expression to match base64 encoded strings
	base64Regex = regexp.MustCompile(`^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=|[A-Za-z0-9+\\/]{4})$`)
	// Non-alphanumeric characters regex
	nonAlphaNumeric = regexp.MustCompile(`\W+`)
	// Space followed by letter regex
	spaceFollowedByLetter = regexp.MustCompile(`\s+([a-zA-Z])`)
	// Valid Go identifier regex
	validGoIdentifier = regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_]*$`)
	// Cached title case converter
	titleCaser = cases.Title(language.Und)
)

func ConvertToGoStructs(data any, flatten bool, formatType string) (string, error) {
	var (
		structs    = make(map[string]string)
		mainStruct = "AutoGenerated"
		result     strings.Builder
	)

	// If the top-level element is an array, take the first element as the base for struct generation
	if arr, ok := data.([]any); ok && len(arr) > 0 {
		data = arr[0]
	}

	structs[mainStruct] = parseScope(data, mainStruct, flatten, structs, formatType)

	keys := make([]string, 0, len(structs))
	for key := range structs {
		keys = append(keys, key)
	}

	sort.Strings(keys)
	for _, name := range keys {
		definition := structs[name]
		result.WriteString(fmt.Sprintf("type %s struct {\n%s}\n\n", titleCaser.String(name), definition))
	}

	code := result.String()
	wrappedCode := "package main\n\n" + code
	if err := validateGoCode(wrappedCode); err != nil {
		return "", fmt.Errorf("error validating Go code: %w", err)
	}

	formatted, err := format.Source([]byte(code))
	if err != nil {
		return "", fmt.Errorf("error formatting Go code: %w", err)
	}

	return string(formatted), nil
}

func parseScope(scope any, structName string, flatten bool, structs map[string]string, formatType string) string {
	var goCode strings.Builder
	fieldNames := make(map[string]int)
	fieldOrder := make([]string, 0)

	switch scope := scope.(type) {
	case map[string]any:
		for k, v := range scope {
			fieldName := toCamelCase(k)
			if fieldName == "" || !validGoIdentifier.MatchString(fieldName) {
				fieldName = "NAMING_FAILED"
				if count, exists := fieldNames[fieldName]; exists {
					fieldNames[fieldName] = count + 1
					fieldName = fmt.Sprintf("%s%d", fieldName, count+1)
				} else {
					fieldNames[fieldName] = 1
				}
			}
			if isNumeric(fieldName) || startsWithDigit(fieldName) {
				fieldName = formatNumber(fieldName)
			}
			fieldType := goType(v, fieldName, flatten, structs, formatType)
			tag := getTag(k, formatType)
			fieldOrder = append(fieldOrder, fmt.Sprintf("\t%s %s `%s`\n", titleCaser.String(fieldName), fieldType, tag))
		}
	case []any:
		if len(scope) > 0 {
			elemType := goType(scope[0], structName, flatten, structs, formatType)
			goCode.WriteString(fmt.Sprintf("[]%s", elemType))
		}
	}

	// Sort the fields alphabetically
	sort.Strings(fieldOrder)
	for _, field := range fieldOrder {
		goCode.WriteString(field)
	}
	return goCode.String()
}

func isBase64(s string) bool {
	// Check if the length is a multiple of 4
	if len(s)%4 != 0 {
		return false
	}

	if !base64Regex.MatchString(s) {
		return false
	}

	decoded, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		return false
	}

	// Check for abnormal characters in the decoded string
	for _, r := range decoded {
		if !utf8.ValidRune(rune(r)) || (r < 32 && r != 9 && r != 10 && r != 13) {
			return false
		}
	}
	// shortest base64 value I could come up with was 5
	// 	echo "" | base64 | wc --chars
	// 5
	// I rather want false negative then false positive results here, so we can fallback to string type
	return len(s) > 5
}

func goType(value any, fieldName string, flatten bool, structs map[string]string, formatType string) string {
	switch value := value.(type) {
	case string:
		if iso8601Regex.MatchString(value) {
			return "time.Time"
		}
		if isBase64(value) {
			return "[]byte"
		}
		return "string"
	case float64:
		if value == float64(int64(value)) {
			if value >= -2147483648 && value <= 2147483647 {
				return "int"
			}
			return "int64"
		}
		return "float64"
	case bool:
		return "bool"
	case map[string]any:
		nestedStructName := toCamelCase(fieldName)
		if !flatten {
			structs[nestedStructName] = parseScope(value, nestedStructName, flatten, structs, formatType)
			return nestedStructName
		}
		return "struct {\n" + parseScope(value, nestedStructName, flatten, structs, formatType) + "\t}"
	case []any:
		if len(value) > 0 {
			elemType := goType(value[0], fieldName, flatten, structs, formatType)
			return "[]" + elemType
		}
		return "[]any"
	default:
		return "any"
	}
}

func getTag(key, formatType string) string {
	if formatType == "yaml" {
		return fmt.Sprintf("yaml:\"%s,omitempty\"", key)
	}
	return fmt.Sprintf("json:\"%s,omitempty\"", key)
}

func toCamelCase(str string) string {
	str = strings.ReplaceAll(str, "-", " ")
	str = strings.ReplaceAll(str, "_", " ")
	str = nonAlphaNumeric.ReplaceAllString(str, " ")
	camelStr := spaceFollowedByLetter.ReplaceAllStringFunc(str, func(s string) string {
		return strings.ToUpper(strings.TrimSpace(s))
	})
	return titleCaser.String(strings.ReplaceAll(camelStr, " ", ""))
}

func isNumeric(s string) bool {
	_, err := strconv.Atoi(s)
	return err == nil
}

func startsWithDigit(s string) bool {
	return len(s) > 0 && s[0] >= '0' && s[0] <= '9'
}

func formatNumber(str string) string {
	if str == "" {
		return ""
	}
	if isNumeric(str) {
		return "Num" + str
	}
	if startsWithDigit(str) {
		numbers := map[byte]string{
			'0': "Zero_",
			'1': "One_",
			'2': "Two_",
			'3': "Three_",
			'4': "Four_",
			'5': "Five_",
			'6': "Six_",
			'7': "Seven_",
			'8': "Eight_",
			'9': "Nine_",
		}
		return numbers[str[0]] + str[1:]
	}
	return str
}

func validateGoCode(code string) error {
	fset := token.NewFileSet()
	_, err := parser.ParseFile(fset, "", code, parser.AllErrors)
	if err != nil {
		return fmt.Errorf("go code validation failed: %w", err)
	}
	return nil
}
